(()=>{"use strict";function t(s){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},t(s)}function s(s){var e=function(s,e){if("object"!=t(s)||!s)return s;var o=s[Symbol.toPrimitive];if(void 0!==o){var r=o.call(s,e||"default");if("object"!=t(r))return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(s)}(s,"string");return"symbol"==t(e)?e:e+""}function e(t,e,o){return(e=s(e))in t?Object.defineProperty(t,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):t[e]=o,t}function o(t,s){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);s&&(o=o.filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable})),e.push.apply(e,o)}return e}function r(t){for(var s=1;s<arguments.length;s++){var r=null!=arguments[s]?arguments[s]:{};s%2?o(Object(r),!0).forEach(function(s){e(t,s,r[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach(function(s){Object.defineProperty(t,s,Object.getOwnPropertyDescriptor(r,s))})}return t}class i{constructor(t,s,e){this.id=t,this.x=s,this.y=e}}class n{constructor(t,s){this.sourceId=t,this.targetId=s}}const c=150,a=60,l=80,h=120,u=250,f=300,d=350,m=.7,p=.95,g=.1,b=.02,y=.98,E=50,v={NAMES:["blue","red","green","yellow","purple","orange","cyan","magenta","lime","pink"]};class M{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;this.width=t,this.height=s,this.area=t*s}aplicar(t,s){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:200;const o=t.length,r=Math.sqrt(this.area/o)*m;let i=this.width*g;const n=p;for(let c=0;c<e;c++)this.calcularFuerzasRepulsivas(t,r),this.calcularFuerzasAtractivas(t,s,r),this.aplicarFuerzas(t,i),i*=n;t.forEach(t=>{delete t.forceX,delete t.forceY})}_calcularDistanciaSegura(t,s){return 0===t&&0===s?{deltaX:.01*(Math.random()-.5),deltaY:.01*(Math.random()-.5),distancia:.01}:{deltaX:t,deltaY:s,distancia:Math.sqrt(t*t+s*s)}}calcularFuerzasRepulsivas(t,s){for(let e=0;e<t.length;e++){t[e].forceX=0,t[e].forceY=0;for(let o=0;o<t.length;o++){if(e===o)continue;const{deltaX:r,deltaY:i,distancia:n}=this._calcularDistanciaSegura(t[e].x-t[o].x,t[e].y-t[o].y),c=s*s/n;t[e].forceX+=r/n*c,t[e].forceY+=i/n*c}}}calcularFuerzasAtractivas(t,s,e){const o=new Map(t.map(t=>[t.id,t]));for(const r of s){const t=o.get(r.sourceId),s=o.get(r.targetId);if(!t||!s)continue;const{deltaX:i,deltaY:n,distancia:c}=this._calcularDistanciaSegura(s.x-t.x,s.y-t.y),a=c*c/e,l=i/c*a,h=n/c*a;t.forceX+=l,t.forceY+=h,s.forceX-=l,s.forceY-=h}}aplicarFuerzas(t,s){for(const e of t){const t=e.forceX,o=e.forceY,r=Math.sqrt(t*t+o*o)||.001,i=Math.min(r,s);e.x+=t/r*i,e.y+=o/r*i,e.x=Math.max(b,Math.min(y,e.x)),e.y=Math.max(b,Math.min(y,e.y))}}}class C{constructor(){this.nodos=[],this.aristas=[]}agregarNodo(t,s){if(this.nodos.length>=c)throw new Error("Se alcanz\xf3 el m\xe1ximo de ".concat(c," nodos permitidos."));const e=this.nodos.length>0?this.nodos[this.nodos.length-1].id+1:1,o=new i(e,t,s);return this.nodos.push(o),o}agregarArista(t,s){if(t===s)return null;if(this.aristas.some(e=>e.sourceId===t&&e.targetId===s||e.sourceId===s&&e.targetId===t))return null;const e=new n(t,s);return this.aristas.push(e),e}resetear(){this.nodos=[],this.aristas=[]}actualizarPosicionNodo(t,s,e){const o=this.nodos.find(s=>s.id===t);o&&(o.x=s,o.y=e)}eliminarArista(t,s){this.aristas=this.aristas.filter(e=>!(e.sourceId===t&&e.targetId===s||e.sourceId===s&&e.targetId===t))}eliminarNodo(t){this.nodos=this.nodos.filter(s=>s.id!==t),this.aristas=this.aristas.filter(s=>s.sourceId!==t&&s.targetId!==t)}static crearGrafoConectadoAleatorio(t){if(t<a||t>c)throw new Error("El n\xfamero de nodos debe estar entre ".concat(a," y ").concat(c,"."));const s=new C,e=Math.ceil(Math.sqrt(t)),o=Math.ceil(t/e),r=(t,s,e,o)=>({x:.05+.9*((t+.5+.8*(Math.random()-.5))/e),y:.05+.9*((s+.5+.8*(Math.random()-.5))/o)});for(let c=0;c<t;c++){const t=c%e,i=Math.floor(c/e),{x:n,y:a}=r(t,i,e,o);s.agregarNodo(n,a)}for(let c=1;c<s.nodos.length;c++){const t=s.nodos[Math.floor(Math.random()*c)];s.agregarArista(s.nodos[c].id,t.id)}const i=Math.floor(t/4);let n=0,m=0,p=t*t;for(;n<i&&m++<p;){const t=s.nodos[Math.floor(Math.random()*s.nodos.length)],e=s.nodos[Math.floor(Math.random()*s.nodos.length)];t.id!==e.id&&s.agregarArista(t.id,e.id)&&n++}const g=t<l?u:t<h?f:d;return s.aplicarLayoutFuerzas(g),s}aplicarLayoutFuerzas(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:600;new M(1,1).aplicar(this.nodos,this.aristas,t)}}function w(t,s){const e={};for(const o of t){const t=s[Math.floor(Math.random()*s.length)];e[o.id]=t}return e}function x(t,s,e,o,r){return{attempts:t,conflicts:o===1/0?0:o,meanConflicts:t>0?e/t:0,successRate:t>0?s/t:0,progress:r>0?Math.min(t/r,1):1}}class I{constructor(t){var s;let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};var o;this.nodes=t.nodos,this.edges=t.aristas,this.numberOfColors=null!==(s=e.numberOfColors)&&void 0!==s?s:3,this.availableColors=(o=this.numberOfColors,v.NAMES.slice(0,o)),this.attempts=0,this.totalConflicts=0,this.successCount=0,this.bestColors={},this.bestEvaluation={conflicts:1/0,conflictEdges:[]},this.finished=!1,this.attemptsHistory=[]}evaluarColoracion(t){return function(t,s){let e=0;const o=[];for(const r of t){const t=s[r.sourceId],i=s[r.targetId];t&&i&&t===i&&(e++,o.push({sourceId:r.sourceId,targetId:r.targetId}))}return{conflicts:e,conflictEdges:o}}(this.edges,t)}obtenerMaximoIntentos(){throw new Error("obtenerMaximoIntentos() debe ser implementado por la subclase")}guardarIntentoEnHistorial(t,s){this.attemptsHistory.push({attemptNumber:this.attempts,conflicts:t,success:s,timestamp:Date.now()})}actualizarMejorSolucion(t,s,e){s<this.bestEvaluation.conflicts&&(this.bestEvaluation={conflicts:s,conflictEdges:e},this.bestColors=t)}updateStatistics(t,s){this.attempts++,this.totalConflicts+=t,s&&this.successCount++}run(t){let s=null;for(;;){s=this.step();const e=this.attempts%E===0||s.done;if(t&&e){t({progress:this.calculateProgress(),attempts:this.attempts,conflicts:s.stats.conflicts,colors:s.colors,conflictEdges:s.conflictEdges,meanConflicts:s.stats.meanConflicts,successRate:s.stats.successRate,currentAttempt:s.currentAttempt})}if(s.done)break}return{colors:s.colors,conflictEdges:s.conflictEdges,stats:{attempts:s.stats.attempts,conflicts:s.stats.conflicts,meanConflicts:s.stats.meanConflicts,successRate:s.stats.successRate}}}calculateProgress(){throw new Error("calculateProgress() debe ser implementado por la subclase")}step(){throw new Error("step() debe ser implementado por la subclase")}}class A extends I{constructor(t){var s;let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(t,e),this.maxAttempts=null!==(s=e.maxAttempts)&&void 0!==s?s:1/0}obtenerMaximoIntentos(){return this.maxAttempts}calculateProgress(){return this.maxAttempts===1/0?0:this.attempts/this.maxAttempts}step(){if(this.finished||this.attempts>=this.maxAttempts){this.finished=!0;const t=x(this.attempts,this.successCount,this.totalConflicts,this.bestEvaluation.conflicts,this.obtenerMaximoIntentos());return{done:!0,colors:this.bestColors||{},conflictEdges:this.bestEvaluation.conflictEdges,stats:t,currentAttempt:{conflicts:this.bestEvaluation.conflicts,success:0===this.bestEvaluation.conflicts}}}const t=w(this.nodes,this.availableColors),s=this.evaluarColoracion(t),e={colors:t,success:0===s.conflicts,conflicts:s.conflicts,conflictEdges:s.conflictEdges};this.updateStatistics(e.conflicts,e.success),this.guardarIntentoEnHistorial(e.conflicts,e.success),this.actualizarMejorSolucion(e.colors,e.conflicts,e.conflictEdges),e.success&&(this.finished=!0);const o=x(this.attempts,this.successCount,this.totalConflicts,this.bestEvaluation.conflicts,this.obtenerMaximoIntentos());return{done:this.finished||this.attempts>=this.maxAttempts,colors:this.bestColors||e.colors,conflictEdges:this.bestEvaluation.conflictEdges,stats:o,currentAttempt:{conflicts:e.conflicts,success:e.success}}}}class O extends I{constructor(t){var s;let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(t,e),this.iterations=null!==(s=e.iterations)&&void 0!==s?s:1e3}obtenerMaximoIntentos(){return this.iterations}calculateProgress(){return this.iterations>0?this.attempts/this.iterations:0}step(){if(this.finished||this.attempts>=this.iterations){this.finished=!0;const t=x(this.attempts,this.successCount,this.totalConflicts,this.bestEvaluation.conflicts,this.obtenerMaximoIntentos());return{done:!0,colors:this.bestColors||{},conflictEdges:this.bestEvaluation.conflictEdges,stats:t,currentAttempt:{conflicts:this.bestEvaluation.conflicts,success:0===this.bestEvaluation.conflicts}}}const t=w(this.nodes,this.availableColors),s=this.evaluarColoracion(t),{conflicts:e,conflictEdges:o}=s,r=0===e;this.updateStatistics(e,r),this.guardarIntentoEnHistorial(e,r),e<this.bestEvaluation.conflicts&&this.actualizarMejorSolucion(t,e,o);const i=x(this.attempts,this.successCount,this.totalConflicts,this.bestEvaluation.conflicts,this.obtenerMaximoIntentos());return{done:this.finished||this.attempts>=this.iterations,colors:this.bestColors||{},conflictEdges:this.bestEvaluation.conflictEdges,stats:i,currentAttempt:{conflicts:e,success:r}}}}self.onmessage=function(t){const{type:s,data:e}=t.data;try{if("colorLasVegas"===s){const t=new C;t.nodos=e.graph.nodes,t.aristas=e.graph.edges;const s=e.options||{},o=performance.now(),i=new A(t,s);let n=0;const c=t=>{const s=performance.now(),e=i.attemptsHistory.slice(n);n=i.attemptsHistory.length,self.postMessage({type:"colorProgress",progress:t.progress,attempts:t.attempts,conflicts:t.conflicts,colors:t.colors,conflictEdges:t.conflictEdges,meanConflicts:t.meanConflicts,successRate:t.successRate,timeMs:s-o,currentAttempt:t.currentAttempt,newAttempts:e})},a=i.run(c),l=performance.now();self.postMessage({type:"colorComplete",algorithm:"Las Vegas",result:{colors:a.colors,conflictEdges:a.conflictEdges,stats:r(r({},a.stats),{},{timeMs:l-o}),attemptsHistory:i.attemptsHistory}})}if("colorMonteCarlo"===s){const t=new C;t.nodos=e.graph.nodes,t.aristas=e.graph.edges;const s=e.options||{},o=performance.now(),i=new O(t,s);let n=0;const c=t=>{const s=performance.now(),e=i.attemptsHistory.slice(n);n=i.attemptsHistory.length,self.postMessage({type:"colorProgress",progress:t.progress,attempts:t.attempts,conflicts:t.conflicts,colors:t.colors,conflictEdges:t.conflictEdges,meanConflicts:t.meanConflicts,successRate:t.successRate,timeMs:s-o,currentAttempt:t.currentAttempt,newAttempts:e})},a=i.run(c),l=performance.now();self.postMessage({type:"colorComplete",algorithm:"Monte Carlo",result:{colors:a.colors,conflictEdges:a.conflictEdges,stats:r(r({},a.stats),{},{timeMs:l-o}),attemptsHistory:i.attemptsHistory}})}}catch(o){self.postMessage({type:"error",error:o.message,stack:o.stack})}}})();
//# sourceMappingURL=40.e4deed3d.chunk.js.map