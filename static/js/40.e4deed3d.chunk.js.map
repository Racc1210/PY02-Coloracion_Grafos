{"version":3,"file":"static/js/40.e4deed3d.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","models/Node.js","models/Edge.js","models/constants/index.js","models/ForceDirectedLayout.js","models/Graph.js","models/utils/graphEvaluation.js","models/algorithms/BaseAlgorithm.js","models/utils/colorPalette.js","models/algorithms/LasVegas.js","models/algorithms/MonteCarlo.js","controllers/workers/GraphWorker.js"],"sourcesContent":["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nexport { _objectSpread2 as default };","// src/models/Node.js\r\n\r\n/**\r\n * Representa un nodo en el grafo.\r\n * Los nodos tienen coordenadas normalizadas (0-1) para posicionamiento independiente del viewport.\r\n * @class\r\n */\r\nexport default class Node {\r\n  /**\r\n   * Crea un nuevo nodo del grafo.\r\n   * @param {number} id - Identificador único del nodo.\r\n   * @param {number} x - Posición X normalizada (0 a 1).\r\n   * @param {number} y - Posición Y normalizada (0 a 1).\r\n   */\r\n  constructor(id, x, y) {\r\n    /** @type {number} Identificador único del nodo. */\r\n    this.id = id;\r\n\r\n    /** @type {number} Coordenada X normalizada. */\r\n    this.x = x;\r\n\r\n    /** @type {number} Coordenada Y normalizada. */\r\n    this.y = y;\r\n  }\r\n}\r\n","/**\r\n * Representa una arista no dirigida que conecta dos nodos en el grafo.\r\n * @class\r\n */\r\nexport default class Edge {\r\n  /**\r\n   * Crea una nueva arista del grafo.\r\n   * @param {number} sourceId - Identificador del nodo origen.\r\n   * @param {number} targetId - Identificador del nodo destino.\r\n   */\r\n  constructor(sourceId, targetId) {\r\n    /** @type {number} Identificador del nodo origen. */\r\n    this.sourceId = sourceId;\r\n\r\n    /** @type {number} Identificador del nodo destino. */\r\n    this.targetId = targetId;\r\n  }\r\n}\r\n","// Constantes de la capa modelo\r\n\r\n// RESTRICCIONES DEL GRAFO\r\nexport const GRAPH_CONSTRAINTS = {\r\n    MAX_NODES: 150,\r\n    MIN_RANDOM_NODES: 60,\r\n    MIN_COLORS: 3,\r\n    MAX_COLORS: 10,\r\n    DEFAULT_COLORS: 3\r\n};\r\n\r\n// LAYOUT ITERATIONS\r\nexport const LAYOUT_ITERATIONS = {\r\n    SMALL_GRAPH_THRESHOLD: 80,\r\n    MEDIUM_GRAPH_THRESHOLD: 120,\r\n    SMALL_GRAPH: 250,\r\n    MEDIUM_GRAPH: 300,\r\n    LARGE_GRAPH: 350\r\n};\r\n\r\n// FORCE DIRECTED LAYOUT CONSTANTS\r\nexport const FORCE_DIRECTED = {\r\n    K_MULTIPLIER: 0.7,\r\n    COOLING_RATE: 0.95,\r\n    TEMPERATURE_FACTOR: 0.1,\r\n    POSITION_MIN: 0.02,\r\n    POSITION_MAX: 0.98\r\n};\r\n\r\n// ALGORITHM CONFIGURATION \r\nexport const ALGORITHM = {\r\n    BATCH_SIZE: 50,\r\n    LOCAL_SEARCH_DELAY: 150\r\n};\r\n\r\nexport const COLOR_PALETTE = {\r\n    NAMES: [\"blue\", \"red\", \"green\", \"yellow\", \"purple\", \"orange\", \"cyan\", \"magenta\", \"lime\", \"pink\"]\r\n};\r\n","import { FORCE_DIRECTED } from \"./constants/index.js\";\r\n\r\n/**\r\n * Implementa el algoritmo de layout dirigido por fuerzas de Fruchterman-Reingold.\r\n * @class\r\n */\r\nexport default class ForceDirectedLayout {\r\n    /**\r\n     * Crea un nuevo layout dirigido por fuerzas.\r\n     * @param {number} [width=1.0] - Ancho del área de layout.\r\n     * @param {number} [height=1.0] - Alto del área de layout.\r\n     */\r\n    constructor(width = 1.0, height = 1.0) {\r\n        /** @type {number} Ancho del área de layout. */\r\n        this.width = width;\r\n\r\n        /** @type {number} Alto del área de layout. */\r\n        this.height = height;\r\n\r\n        /** @type {number} Área total para cálculos de fuerzas. */\r\n        this.area = width * height;\r\n    }\r\n\r\n    /**\r\n     * Aplica el algoritmo de layout dirigido por fuerzas para posicionar nodos.\r\n     * @param {Array<Node>} nodos - Array de nodos a posicionar.\r\n     * @param {Array<Edge>} aristas - Array de aristas que conectan nodos.\r\n     * @param {number} [iteraciones=200] - Número de iteraciones de la simulación.\r\n     */\r\n    aplicar(nodos, aristas, iteraciones = 200) {\r\n        const numeroDeNodos = nodos.length;\r\n        const distanciaOptima = Math.sqrt(this.area / numeroDeNodos) * FORCE_DIRECTED.K_MULTIPLIER;\r\n        let temperatura = this.width * FORCE_DIRECTED.TEMPERATURE_FACTOR;\r\n        const tasaEnfriamiento = FORCE_DIRECTED.COOLING_RATE;\r\n\r\n        for (let indiceIteracion = 0; indiceIteracion < iteraciones; indiceIteracion++) {\r\n            this.calcularFuerzasRepulsivas(nodos, distanciaOptima);\r\n            this.calcularFuerzasAtractivas(nodos, aristas, distanciaOptima);\r\n            this.aplicarFuerzas(nodos, temperatura);\r\n            temperatura *= tasaEnfriamiento;\r\n        }\r\n\r\n        nodos.forEach(nodo => {\r\n            delete nodo.forceX;\r\n            delete nodo.forceY;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Calcula la distancia segura entre dos puntos, evitando división por cero.\r\n     * @param {number} deltaX - Diferencia en coordenadas X.\r\n     * @param {number} deltaY - Diferencia en coordenadas Y.\r\n     * @returns {Object} Objeto con propiedades deltaX, deltaY y distancia.\r\n     * @private\r\n     */\r\n    _calcularDistanciaSegura(deltaX, deltaY) {\r\n        if (deltaX === 0 && deltaY === 0) {\r\n            return {\r\n                deltaX: (Math.random() - 0.5) * 0.01,\r\n                deltaY: (Math.random() - 0.5) * 0.01,\r\n                distancia: 0.01\r\n            };\r\n        }\r\n        return {\r\n            deltaX,\r\n            deltaY,\r\n            distancia: Math.sqrt(deltaX * deltaX + deltaY * deltaY)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calcula fuerzas repulsivas entre todos los pares de nodos.\r\n     * @param {Array<Node>} nodos - Array de nodos.\r\n     * @param {number} distanciaOptima - Distancia óptima entre nodos.\r\n     * @private\r\n     */\r\n    calcularFuerzasRepulsivas(nodos, distanciaOptima) {\r\n        for (let i = 0; i < nodos.length; i++) {\r\n            nodos[i].forceX = 0;\r\n            nodos[i].forceY = 0;\r\n\r\n            for (let j = 0; j < nodos.length; j++) {\r\n                if (i === j) continue;\r\n\r\n                const { deltaX, deltaY, distancia } = this._calcularDistanciaSegura(\r\n                    nodos[i].x - nodos[j].x,\r\n                    nodos[i].y - nodos[j].y\r\n                );\r\n\r\n                const fuerzaRepulsiva = (distanciaOptima * distanciaOptima) / distancia;\r\n\r\n                nodos[i].forceX += (deltaX / distancia) * fuerzaRepulsiva;\r\n                nodos[i].forceY += (deltaY / distancia) * fuerzaRepulsiva;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calcula fuerzas atractivas a lo largo de las aristas.\r\n     * Fórmula: Fuerza = distancia² / distanciaOptima\r\n     * @param {Array<Node>} nodos - Array de nodos.\r\n     * @param {Array<Edge>} aristas - Array de aristas.\r\n     * @param {number} distanciaOptima - Distancia óptima entre nodos.\r\n     * @private\r\n     */\r\n    calcularFuerzasAtractivas(nodos, aristas, distanciaOptima) {\r\n        const nodoMap = new Map(nodos.map(n => [n.id, n]));\r\n\r\n        for (const arista of aristas) {\r\n            const nodoOrigen = nodoMap.get(arista.sourceId);\r\n            const nodoDestino = nodoMap.get(arista.targetId);\r\n\r\n            if (!nodoOrigen || !nodoDestino) continue;\r\n\r\n            const { deltaX, deltaY, distancia } = this._calcularDistanciaSegura(\r\n                nodoDestino.x - nodoOrigen.x,\r\n                nodoDestino.y - nodoOrigen.y\r\n            );\r\n\r\n            const fuerzaAtractiva = (distancia * distancia) / distanciaOptima;\r\n\r\n            const fuerzaX = (deltaX / distancia) * fuerzaAtractiva;\r\n            const fuerzaY = (deltaY / distancia) * fuerzaAtractiva;\r\n\r\n            nodoOrigen.forceX += fuerzaX;\r\n            nodoOrigen.forceY += fuerzaY;\r\n            nodoDestino.forceX -= fuerzaX;\r\n            nodoDestino.forceY -= fuerzaY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Aplica fuerzas acumuladas a las posiciones de los nodos.\r\n     * @param {Array<Node>} nodos - Array de nodos.\r\n     * @param {number} temperatura - Temperatura actual (controla el desplazamiento máximo).\r\n     * @private\r\n     */\r\n    aplicarFuerzas(nodos, temperatura) {\r\n        for (const nodo of nodos) {\r\n            const fuerzaX = nodo.forceX;\r\n            const fuerzaY = nodo.forceY;\r\n            const magnitudFuerza = Math.sqrt(fuerzaX * fuerzaX + fuerzaY * fuerzaY) || 0.001;\r\n\r\n            const desplazamiento = Math.min(magnitudFuerza, temperatura);\r\n\r\n            nodo.x += (fuerzaX / magnitudFuerza) * desplazamiento;\r\n            nodo.y += (fuerzaY / magnitudFuerza) * desplazamiento;\r\n\r\n            // Mantener nodos dentro de los límites\r\n            nodo.x = Math.max(\r\n                FORCE_DIRECTED.POSITION_MIN,\r\n                Math.min(FORCE_DIRECTED.POSITION_MAX, nodo.x)\r\n            );\r\n            nodo.y = Math.max(\r\n                FORCE_DIRECTED.POSITION_MIN,\r\n                Math.min(FORCE_DIRECTED.POSITION_MAX, nodo.y)\r\n            );\r\n        }\r\n    }\r\n}\r\n","import Node from \"./Node\";\r\nimport Edge from \"./Edge\";\r\nimport ForceDirectedLayout from \"./ForceDirectedLayout\";\r\nimport { GRAPH_CONSTRAINTS, LAYOUT_ITERATIONS } from \"./constants/index.js\";\r\n\r\n/**\r\n * Representa una estructura de datos de grafo.\r\n * @class\r\n */\r\nexport default class Graph {\r\n  /**\r\n   * Crea un nuevo grafo vacío.\r\n   */\r\n  constructor() {\r\n    /** @type {Array<Node>} Array de nodos del grafo. */\r\n    this.nodos = [];\r\n\r\n    /** @type {Array<Edge>} Array de aristas del grafo. */\r\n    this.aristas = [];\r\n  }\r\n\r\n  /**\r\n   * Agrega un nuevo nodo al grafo.\r\n   * @param {number} x - Coordenada X normalizada (0-1)/(0%-100%).\r\n   * @param {number} y - Coordenada Y normalizada (0-1)/(0%-100%).\r\n   * @returns {Node} El nodo recién creado.\r\n   * @throws {Error} Si se alcanza el límite máximo de nodos.\r\n   */\r\n  agregarNodo(x, y) {\r\n    if (this.nodos.length >= GRAPH_CONSTRAINTS.MAX_NODES) {\r\n      throw new Error(`Se alcanzó el máximo de ${GRAPH_CONSTRAINTS.MAX_NODES} nodos permitidos.`);\r\n    }\r\n\r\n    const siguienteIdNodo =\r\n      this.nodos.length > 0\r\n        ? this.nodos[this.nodos.length - 1].id + 1\r\n        : 1;\r\n\r\n    const nuevoNodo = new Node(siguienteIdNodo, x, y);\r\n    this.nodos.push(nuevoNodo);\r\n    return nuevoNodo;\r\n  }\r\n\r\n  /**\r\n   * Agrega una arista entre dos nodos.\r\n   * @param {number} sourceId - Identificador del nodo origen.\r\n   * @param {number} targetId - Identificador del nodo destino.\r\n   * @returns {Edge|null} La arista recién creada, o null si es inválida.\r\n   */\r\n  agregarArista(sourceId, targetId) {\r\n    if (sourceId === targetId) return null;\r\n\r\n    //evitar duplicados \r\n    const aristaExiste = this.aristas.some(\r\n      (arista) =>\r\n        (arista.sourceId === sourceId && arista.targetId === targetId) ||\r\n        (arista.sourceId === targetId && arista.targetId === sourceId)\r\n    );\r\n    if (aristaExiste) return null;\r\n\r\n    //crear nueva arista\r\n    const nuevaArista = new Edge(sourceId, targetId);\r\n    this.aristas.push(nuevaArista);\r\n    return nuevaArista;\r\n  }\r\n\r\n  /**\r\n   * Limpia todos los nodos y aristas del grafo.\r\n   */\r\n  resetear() {\r\n    this.nodos = [];\r\n    this.aristas = [];\r\n  }\r\n\r\n  /**\r\n   * Actualiza la posición de un nodo.\r\n   * @param {number} nodeId - Identificador del nodo a actualizar.\r\n   * @param {number} x - Nueva coordenada X normalizada (0-1).\r\n   * @param {number} y - Nueva coordenada Y normalizada (0-1).\r\n   */\r\n  actualizarPosicionNodo(nodeId, x, y) {\r\n    const nodo = this.nodos.find((n) => n.id === nodeId);\r\n    if (!nodo) return;\r\n    nodo.x = x;\r\n    nodo.y = y;\r\n  }\r\n\r\n  /**\r\n   * Remueve una arista.\r\n   * @param {number} sourceId - Identificador del primer nodo.\r\n   * @param {number} targetId - Identificador del segundo nodo.\r\n   */\r\n  eliminarArista(sourceId, targetId) {\r\n    this.aristas = this.aristas.filter(\r\n      (arista) =>\r\n        !(\r\n          (arista.sourceId === sourceId && arista.targetId === targetId) ||\r\n          (arista.sourceId === targetId && arista.targetId === sourceId)\r\n        )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Remueve un nodo y todas sus aristas conectadas del grafo.\r\n   * @param {number} nodeId - Identificador del nodo a eliminar.\r\n   */\r\n  eliminarNodo(nodeId) {\r\n    // Remover el nodo\r\n    this.nodos = this.nodos.filter((nodo) => nodo.id !== nodeId);\r\n\r\n    // Remover todas las aristas conectadas a este nodo\r\n    this.aristas = this.aristas.filter(\r\n      (arista) => arista.sourceId !== nodeId && arista.targetId !== nodeId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Crea un grafo conectado aleatorio con el número especificado de nodos.\r\n   * Usa posicionamiento basado en grilla con variación aleatoria y layout dirigido por fuerzas.\r\n   * @param {number} numeroDeNodos - Número de nodos a generar.\r\n   * @returns {Graph} Un nuevo grafo aleatorio conectado.\r\n   * @throws {Error} Si numeroDeNodos está fuera del rango válido.\r\n   * @static\r\n   */\r\n  static crearGrafoConectadoAleatorio(numeroDeNodos) {\r\n    if (\r\n      numeroDeNodos < GRAPH_CONSTRAINTS.MIN_RANDOM_NODES ||\r\n      numeroDeNodos > GRAPH_CONSTRAINTS.MAX_NODES\r\n    ) {\r\n      throw new Error(\r\n        `El número de nodos debe estar entre ${GRAPH_CONSTRAINTS.MIN_RANDOM_NODES} y ${GRAPH_CONSTRAINTS.MAX_NODES}.`\r\n      );\r\n    }\r\n\r\n    const grafo = new Graph();\r\n\r\n    // Distribuir nodos en grilla con variación aleatoria\r\n    const columnas = Math.ceil(Math.sqrt(numeroDeNodos));\r\n    const filas = Math.ceil(numeroDeNodos / columnas);\r\n\r\n    const generarCoordenada = (col, fila, maxCol, maxFila) => {\r\n      const xNorm = (col + 0.5 + (Math.random() - 0.5) * 0.8) / maxCol;\r\n      const yNorm = (fila + 0.5 + (Math.random() - 0.5) * 0.8) / maxFila;\r\n      return {\r\n        x: 0.05 + xNorm * 0.9,\r\n        y: 0.05 + yNorm * 0.9\r\n      };\r\n    };\r\n\r\n    for (let i = 0; i < numeroDeNodos; i++) {\r\n      const col = i % columnas;\r\n      const fila = Math.floor(i / columnas);\r\n      const { x, y } = generarCoordenada(col, fila, columnas, filas);\r\n      grafo.agregarNodo(x, y);\r\n    }\r\n\r\n    // Crear árbol de expansión para conectar los nodos\r\n    for (let i = 1; i < grafo.nodos.length; i++) {\r\n      const nodoPrevio = grafo.nodos[Math.floor(Math.random() * i)];\r\n      grafo.agregarArista(grafo.nodos[i].id, nodoPrevio.id);\r\n    }\r\n\r\n    // Agregar aristas extra aleatorias\r\n    const extras = Math.floor(numeroDeNodos / 4);\r\n    let agregadas = 0, intentos = 0, maxIntentos = numeroDeNodos * numeroDeNodos;\r\n\r\n    while (agregadas < extras && intentos++ < maxIntentos) {\r\n      const a = grafo.nodos[Math.floor(Math.random() * grafo.nodos.length)];\r\n      const b = grafo.nodos[Math.floor(Math.random() * grafo.nodos.length)];\r\n      if (a.id !== b.id && grafo.agregarArista(a.id, b.id)) {\r\n        agregadas++;\r\n      }\r\n    }\r\n\r\n    // Selección de iteraciones de layout\r\n    const iteracionesLayout = numeroDeNodos < LAYOUT_ITERATIONS.SMALL_GRAPH_THRESHOLD\r\n      ? LAYOUT_ITERATIONS.SMALL_GRAPH\r\n      : numeroDeNodos < LAYOUT_ITERATIONS.MEDIUM_GRAPH_THRESHOLD\r\n        ? LAYOUT_ITERATIONS.MEDIUM_GRAPH\r\n        : LAYOUT_ITERATIONS.LARGE_GRAPH;\r\n\r\n    grafo.aplicarLayoutFuerzas(iteracionesLayout);\r\n\r\n    return grafo;\r\n  }\r\n\r\n\r\n  /**\r\n   * Aplica el algoritmo de layout dirigido por fuerzas para posicionar nodos.\r\n   * Usa el algoritmo de Fruchterman-Reingold para distribución natural de nodos.\r\n   * @param {number} [iteraciones=600] - Número de iteraciones de la simulación.\r\n   */\r\n  aplicarLayoutFuerzas(iteraciones = 600) {\r\n    const layout = new ForceDirectedLayout(1.0, 1.0);\r\n    layout.aplicar(this.nodos, this.aristas, iteraciones);\r\n  }\r\n\r\n}\r\n","/**\r\n * Utilidades de evaluación de coloreo de grafos.\r\n * Provee funciones para evaluar calidad de coloración y generar coloraciones.\r\n * @module graphEvaluation\r\n */\r\n\r\n/**\r\n * Evalúa una coloración de grafo contando conflictos.\r\n * @param {Array<Edge>} aristas - Array de aristas del grafo.\r\n * @param {Object} mapaColores - Mapa de IDs de nodos a colores {nodeId: color}.\r\n * @returns {Object} Resultado de evaluación con conteo de conflictos y array de aristas en conflicto.\r\n */\r\nexport function evaluarColoracion(aristas, mapaColores) {\r\n    let conflictos = 0;\r\n    const aristasConflicto = [];\r\n\r\n    for (const arista of aristas) {\r\n        const primerColor = mapaColores[arista.sourceId];\r\n        const segundoColor = mapaColores[arista.targetId];\r\n        if (primerColor && segundoColor && primerColor === segundoColor) {\r\n            conflictos++;\r\n            aristasConflicto.push({\r\n                sourceId: arista.sourceId,\r\n                targetId: arista.targetId,\r\n            });\r\n        }\r\n    }\r\n\r\n    return { conflicts: conflictos, conflictEdges: aristasConflicto };\r\n}\r\n\r\n/**\r\n * Genera una coloración aleatoria para todos los nodos.\r\n * @param {Array<Node>} nodos - Array de nodos del grafo a colorear.\r\n * @param {Array<string>} coloresDisponibles - Array de nombres de colores disponibles.\r\n * @returns {Object} Mapa de colores.\r\n */\r\nexport function coloracionAleatoria(nodos, coloresDisponibles) {\r\n    const colores = {};\r\n    for (const nodo of nodos) {\r\n        const color = coloresDisponibles[Math.floor(Math.random() * coloresDisponibles.length)];\r\n        colores[nodo.id] = color;\r\n    }\r\n    return colores;\r\n}\r\n\r\n/**\r\n * Calcula métricas estadísticas para el rendimiento del algoritmo.\r\n * @param {number} intentos - Número de intentos realizados.\r\n * @param {number} conteoExitos - Número de intentos exitosos.\r\n * @param {number} totalConflictos - Suma acumulada de todos los conflictos a través de los intentos.\r\n * @param {number} mejoresConflictos - Conflictos mínimos encontrados.\r\n * @param {number} maxIntentos - Intentos máximos permitidos.\r\n * @returns {Object} Objeto de estadísticas con intentos, conflictos, media, tasa de éxito y progreso.\r\n */\r\nexport function calcularEstadisticasAlgoritmo(\r\n    intentos,\r\n    conteoExitos,\r\n    totalConflictos,\r\n    mejoresConflictos,\r\n    maxIntentos\r\n) {\r\n    const conflictosPromedio = intentos > 0 ? totalConflictos / intentos : 0;\r\n    const tasaExito = intentos > 0 ? conteoExitos / intentos : 0;\r\n    const progreso = maxIntentos > 0 ? Math.min(intentos / maxIntentos, 1) : 1;\r\n\r\n    return {\r\n        attempts: intentos,\r\n        conflicts: mejoresConflictos === Infinity ? 0 : mejoresConflictos,\r\n        meanConflicts: conflictosPromedio,\r\n        successRate: tasaExito,\r\n        progress: progreso\r\n    };\r\n}\r\n","import { generarPaletaColores } from '../utils/colorPalette.js';\r\nimport { evaluarColoracion } from '../utils/graphEvaluation.js';\r\nimport { ALGORITHM } from '../constants/index.js';\r\n\r\n/**\r\n * Clase base abstracta para los algoritmos de coloración de grafos.\r\n * Provee funcionalidad compartida para los algoritmos Las Vegas y Monte Carlo.\r\n * @abstract\r\n * @class\r\n */\r\nexport default class BaseAlgorithm {\r\n    /**\r\n     * Crea una nueva instancia del algoritmo.\r\n     * @param {Graph} graph - la instancia del grafo.\r\n     * @param {Object} [options={}] - Opciones de configuración del algoritmo.\r\n     * @param {number} [options.numberOfColors] - Número de colores a usar.\r\n     */\r\n    constructor(graph, options = {}) {\r\n        /** @type {Array<Node>} Referencia a los nodos del grafo. */\r\n        this.nodes = graph.nodos;\r\n\r\n        /** @type {Array<Edge>} Referencia a las aristas del grafo. */\r\n        this.edges = graph.aristas;\r\n\r\n        /** @type {number} Número de colores disponibles. */\r\n        this.numberOfColors = options.numberOfColors ?? 3;\r\n\r\n        /** @type {Array<string>} Paleta de colores. */\r\n        this.availableColors = generarPaletaColores(this.numberOfColors);\r\n\r\n        /** @type {number} Número total de intentos realizados. */\r\n        this.attempts = 0;\r\n\r\n        /** @type {number} Suma acumulada de todos los conflictos encontrados. */\r\n        this.totalConflicts = 0;\r\n\r\n        /** @type {number} Número de coloraciones exitosas encontradas. */\r\n        this.successCount = 0;\r\n\r\n        /** @type {Object|null} Mejor coloración encontrada. */\r\n        this.bestColors = {};\r\n\r\n        /** @type {Object} Mejor resultado de evaluación con mínimo de conflictos. */\r\n        this.bestEvaluation = { conflicts: Infinity, conflictEdges: [] };\r\n\r\n        /** @type {boolean} flag de ejecucion del algoritmo. */\r\n        this.finished = false;\r\n\r\n        /** @type {Array<Object>} historial del intentos */\r\n        this.attemptsHistory = [];\r\n    }\r\n\r\n    /**\r\n     * Evalúa una coloración y cuenta los conflictos.\r\n     * @param {Object} mapaColores - Mapa de nodeId -> color.\r\n     * @returns {Object} Resultado de evaluación con conflicts y conflictEdges.\r\n     * @protected\r\n     */\r\n    evaluarColoracion(mapaColores) {\r\n        return evaluarColoracion(this.edges, mapaColores);\r\n    }\r\n\r\n    /**\r\n     * Obtiene el número máximo de intentos permitidos.\r\n     * Debe ser implementado por las subclases.\r\n     * @returns {number} Máximo de intentos.\r\n     * @abstract\r\n     */\r\n    obtenerMaximoIntentos() {\r\n        throw new Error('obtenerMaximoIntentos() debe ser implementado por la subclase');\r\n    }\r\n\r\n    /**\r\n     * Guarda un intento en el historial.\r\n     * @param {number} conflictos - Número de conflictos en este intento.\r\n     * @param {boolean} exito - Si el coloreo fue exitoso.\r\n     * @protected\r\n     */\r\n    guardarIntentoEnHistorial(conflictos, exito) {\r\n        this.attemptsHistory.push({\r\n            attemptNumber: this.attempts,\r\n            conflicts: conflictos,\r\n            success: exito,\r\n            timestamp: Date.now()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Actualiza la mejor solución encontrada hasta ahora si la actual es mejor.\r\n     * @param {Object} colores - Asignación de colores.\r\n     * @param {number} conflictos - Número de conflictos.\r\n     * @param {Array} aristasConflicto - Aristas en conflicto.\r\n     * @protected\r\n     */\r\n    actualizarMejorSolucion(colores, conflictos, aristasConflicto) {\r\n        if (conflictos < this.bestEvaluation.conflicts) {\r\n            this.bestEvaluation = { conflicts: conflictos, conflictEdges: aristasConflicto };\r\n            this.bestColors = colores;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza las estadísticas acumuladas después de un intento.\r\n     * @param {number} conflicts - Número de conflictos en este intento.\r\n     * @param {boolean} success - Si este intento fue exitoso.\r\n     * @protected\r\n     */\r\n    updateStatistics(conflicts, success) {\r\n        this.attempts++;\r\n        this.totalConflicts += conflicts;\r\n        if (success) {\r\n            this.successCount++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ejecuta el algoritmo completo con reporte de progreso.\r\n     * @param {Function} progressCallback - Callback invocado periódicamente con actualizaciones de progreso.\r\n     * @returns {Object} Resultado final con colors, conflictEdges y statistics.\r\n     */\r\n    run(progressCallback) {\r\n        let lastStepResult = null;\r\n\r\n        while (true) {\r\n            lastStepResult = this.step();\r\n\r\n            const shouldReportProgress = (this.attempts % ALGORITHM.BATCH_SIZE === 0) || lastStepResult.done;\r\n            if (progressCallback && shouldReportProgress) {\r\n                const progress = this.calculateProgress();\r\n                progressCallback({\r\n                    progress,\r\n                    attempts: this.attempts,\r\n                    conflicts: lastStepResult.stats.conflicts,\r\n                    colors: lastStepResult.colors,\r\n                    conflictEdges: lastStepResult.conflictEdges,\r\n                    meanConflicts: lastStepResult.stats.meanConflicts,\r\n                    successRate: lastStepResult.stats.successRate,\r\n                    currentAttempt: lastStepResult.currentAttempt\r\n                });\r\n            }\r\n\r\n            if (lastStepResult.done) break;\r\n        }\r\n\r\n        return {\r\n            colors: lastStepResult.colors,\r\n            conflictEdges: lastStepResult.conflictEdges,\r\n            stats: {\r\n                attempts: lastStepResult.stats.attempts,\r\n                conflicts: lastStepResult.stats.conflicts,\r\n                meanConflicts: lastStepResult.stats.meanConflicts,\r\n                successRate: lastStepResult.stats.successRate,\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calcula el progreso actual como una fracción \r\n     * Debe ser implementado por las subclases.\r\n     * @returns {number} Fracción de progreso entre.\r\n     * @abstract\r\n     */\r\n    calculateProgress() {\r\n        throw new Error('calculateProgress() debe ser implementado por la subclase');\r\n    }\r\n\r\n    /**\r\n     * Ejecuta un paso/iteración del algoritmo.\r\n     * Debe ser implementado por las subclases.\r\n     * @returns {Object} Resultado del paso con flag done, colors, conflictEdges y stats.\r\n     * @abstract\r\n     */\r\n    step() {\r\n        throw new Error('step() debe ser implementado por la subclase');\r\n    }\r\n}\r\n","/**\r\n * Utilidades de generación de paleta de colores.\r\n * Provee funciones para generar paletas de colores para el colore de grafos.\r\n * @module colorPalette\r\n */\r\n\r\nimport { COLOR_PALETTE } from '../constants/index.js';\r\n\r\n/**\r\n * Genera una paleta de colores con el número especificado de colores.\r\n * @param {number} numeroColores - Número de colores a incluir (3-10).\r\n * @returns {Array<string>} Array de nombres de colores.\r\n */\r\nexport function generarPaletaColores(numeroColores) {\r\n    return COLOR_PALETTE.NAMES.slice(0, numeroColores);\r\n}\r\n","import BaseAlgorithm from './BaseAlgorithm.js';\r\nimport { coloracionAleatoria, calcularEstadisticasAlgoritmo } from '../utils/graphEvaluation.js';\r\n\r\n/**\r\n * Algoritmo Las Vegas para colorear grafos.\r\n * Genera coloraciones aleatorias hasta encontrar una válida.\r\n * Garantiza que la respuesta que de (si del todo da una respuesta) sea valida.\r\n * @extends BaseAlgorithm\r\n * @class\r\n */\r\nexport default class LasVegas extends BaseAlgorithm {\r\n  /**\r\n   * Crea una nueva instancia del algoritmo Las Vegas.\r\n   * @param {Graph} graph - El grafo a colorear.\r\n   * @param {Object} [options={}] - Opciones del algoritmo.\r\n   * @param {number} [options.maxAttempts=Infinity] - Número máximo de intentos.\r\n   * @param {number} [options.numberOfColors] - Número de colores.\r\n   */\r\n  constructor(graph, options = {}) {\r\n    super(graph, options);\r\n\r\n    /** @type {number} Número máximo de intentos de coloración. */\r\n    this.maxAttempts = options.maxAttempts ?? Infinity;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  obtenerMaximoIntentos() {\r\n    return this.maxAttempts;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  calculateProgress() {\r\n    return this.maxAttempts === Infinity ? 0 : this.attempts / this.maxAttempts;\r\n  }\r\n\r\n  /**\r\n   * Ejecuta una iteración de Las Vegas.\r\n   * @returns {Object} Resultado del paso con flag done, colors, edges y estadísticas.\r\n   * @override\r\n   */\r\n  step() {\r\n    if (this.finished || this.attempts >= this.maxAttempts) {\r\n      this.finished = true;\r\n      const stats = calcularEstadisticasAlgoritmo(\r\n        this.attempts,\r\n        this.successCount,\r\n        this.totalConflicts,\r\n        this.bestEvaluation.conflicts,\r\n        this.obtenerMaximoIntentos()\r\n      );\r\n      return {\r\n        done: true,\r\n        colors: this.bestColors || {},\r\n        conflictEdges: this.bestEvaluation.conflictEdges,\r\n        stats,\r\n        currentAttempt: {\r\n          conflicts: this.bestEvaluation.conflicts,\r\n          success: this.bestEvaluation.conflicts === 0\r\n        }\r\n      };\r\n    }\r\n\r\n    const colors = coloracionAleatoria(this.nodes, this.availableColors);\r\n    const evalResult = this.evaluarColoracion(colors);\r\n\r\n    const attempt = {\r\n      colors,\r\n      success: evalResult.conflicts === 0,\r\n      conflicts: evalResult.conflicts,\r\n      conflictEdges: evalResult.conflictEdges,\r\n    };\r\n\r\n    this.updateStatistics(attempt.conflicts, attempt.success);\r\n    this.guardarIntentoEnHistorial(attempt.conflicts, attempt.success);\r\n    this.actualizarMejorSolucion(attempt.colors, attempt.conflicts, attempt.conflictEdges);\r\n\r\n    if (attempt.success) this.finished = true;\r\n\r\n    const stats = calcularEstadisticasAlgoritmo(\r\n      this.attempts,\r\n      this.successCount,\r\n      this.totalConflicts,\r\n      this.bestEvaluation.conflicts,\r\n      this.obtenerMaximoIntentos()\r\n    );\r\n\r\n    return {\r\n      done: this.finished || this.attempts >= this.maxAttempts,\r\n      colors: this.bestColors || attempt.colors,\r\n      conflictEdges: this.bestEvaluation.conflictEdges,\r\n      stats,\r\n      currentAttempt: {\r\n        conflicts: attempt.conflicts,\r\n        success: attempt.success\r\n      }\r\n    };\r\n  }\r\n}","import BaseAlgorithm from './BaseAlgorithm.js';\r\nimport { coloracionAleatoria, calcularEstadisticasAlgoritmo } from '../utils/graphEvaluation.js';\r\n\r\n/**\r\n * Algoritmo Monte Carlo para colorear grafos.\r\n * retorna la mejor encontrada.\r\n * Provee soluciones aproximadas con tiempo de ejecución garantizado.\r\n * @extends BaseAlgorithm\r\n * @class\r\n */\r\nexport default class MonteCarlo extends BaseAlgorithm {\r\n  /**\r\n   * Crea una nueva instancia del algoritmo Monte Carlo.\r\n   * @param {Graph} graph - El grafo a colorear.\r\n   * @param {Object} [options={}] - Opciones del algoritmo.\r\n   * @param {number} [options.iterations=1000] - Número de muestras a generar.\r\n   * @param {number} [options.numberOfColors] - Número de colores.\r\n   */\r\n  constructor(graph, options = {}) {\r\n    super(graph, options);\r\n\r\n    /** @type {number} Número total de iteraciones. */\r\n    this.iterations = options.iterations ?? 1000;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  obtenerMaximoIntentos() {\r\n    return this.iterations;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  calculateProgress() {\r\n    return this.iterations > 0 ? this.attempts / this.iterations : 0;\r\n  }\r\n\r\n  /**\r\n   * Ejecuta una iteración de Monte Carlo.\r\n   * @returns {Object} Resultado del paso con flag done, colors, edges y estadísticas.\r\n   * @override\r\n   */\r\n  step() {\r\n    if (this.finished || this.attempts >= this.iterations) {\r\n      this.finished = true;\r\n      const stats = calcularEstadisticasAlgoritmo(\r\n        this.attempts,\r\n        this.successCount,\r\n        this.totalConflicts,\r\n        this.bestEvaluation.conflicts,\r\n        this.obtenerMaximoIntentos()\r\n      );\r\n      return {\r\n        done: true,\r\n        colors: this.bestColors || {},\r\n        conflictEdges: this.bestEvaluation.conflictEdges,\r\n        stats,\r\n        currentAttempt: {\r\n          conflicts: this.bestEvaluation.conflicts,\r\n          success: this.bestEvaluation.conflicts === 0\r\n        }\r\n      };\r\n    }\r\n\r\n    const colors = coloracionAleatoria(this.nodes, this.availableColors);\r\n    const evalResult = this.evaluarColoracion(colors);\r\n    const { conflicts, conflictEdges } = evalResult;\r\n    const success = conflicts === 0;\r\n\r\n    this.updateStatistics(conflicts, success);\r\n    this.guardarIntentoEnHistorial(conflicts, success);\r\n\r\n    // Actualizar si encontramos una mejor solución\r\n    if (conflicts < this.bestEvaluation.conflicts) {\r\n      this.actualizarMejorSolucion(colors, conflicts, conflictEdges);\r\n    }\r\n\r\n    const stats = calcularEstadisticasAlgoritmo(\r\n      this.attempts,\r\n      this.successCount,\r\n      this.totalConflicts,\r\n      this.bestEvaluation.conflicts,\r\n      this.obtenerMaximoIntentos()\r\n    );\r\n\r\n    return {\r\n      done: this.finished || this.attempts >= this.iterations,\r\n      colors: this.bestColors || {},\r\n      conflictEdges: this.bestEvaluation.conflictEdges,\r\n      stats,\r\n      currentAttempt: {\r\n        conflicts,\r\n        success\r\n      }\r\n    };\r\n  }\r\n}\r\n","// Web Worker (Module) para ejecutar algoritmos de coloración en background\r\n/* eslint-disable no-restricted-globals */\r\n\r\nimport Graph from '../../models/Graph.js';\r\nimport LasVegas from '../../models/algorithms/LasVegas.js';\r\nimport MonteCarlo from '../../models/algorithms/MonteCarlo.js';\r\n\r\n// Worker Message Handler \r\nself.onmessage = function (e) {\r\n  const { type, data } = e.data;\r\n\r\n  try {\r\n    if (type === 'colorLasVegas') {\r\n      const graph = new Graph();\r\n      graph.nodos = data.graph.nodes;\r\n      graph.aristas = data.graph.edges;\r\n\r\n      const options = data.options || {};\r\n\r\n      const startTime = performance.now();\r\n      const algo = new LasVegas(graph, options);\r\n\r\n      // Rastrear último índice enviado para enviar solo incrementos\r\n      let ultimoIndiceEnviado = 0;\r\n\r\n      // Callback de progreso - enviar solo nuevos intentos\r\n      const progressCallback = (data) => {\r\n        const currentTime = performance.now();\r\n\r\n        // Obtener solo los intentos nuevos desde el último reporte\r\n        const nuevosIntentos = algo.attemptsHistory.slice(ultimoIndiceEnviado);\r\n        ultimoIndiceEnviado = algo.attemptsHistory.length;\r\n\r\n        self.postMessage({\r\n          type: 'colorProgress',\r\n          progress: data.progress,\r\n          attempts: data.attempts,\r\n          conflicts: data.conflicts,\r\n          colors: data.colors,\r\n          conflictEdges: data.conflictEdges,\r\n          meanConflicts: data.meanConflicts,\r\n          successRate: data.successRate,\r\n          timeMs: currentTime - startTime,\r\n          currentAttempt: data.currentAttempt,\r\n          newAttempts: nuevosIntentos  // Solo los nuevos intentos\r\n        });\r\n      };\r\n\r\n      const result = algo.run(progressCallback);\r\n      const endTime = performance.now();\r\n\r\n      self.postMessage({\r\n        type: 'colorComplete',\r\n        algorithm: 'Las Vegas',\r\n        result: {\r\n          colors: result.colors,\r\n          conflictEdges: result.conflictEdges,\r\n          stats: {\r\n            ...result.stats,\r\n            timeMs: endTime - startTime\r\n          },\r\n          attemptsHistory: algo.attemptsHistory\r\n        }\r\n      });\r\n    }\r\n\r\n    if (type === 'colorMonteCarlo') {\r\n      const graph = new Graph();\r\n      graph.nodos = data.graph.nodes;\r\n      graph.aristas = data.graph.edges;\r\n\r\n      const options = data.options || {};\r\n\r\n      const startTime = performance.now();\r\n      const algo = new MonteCarlo(graph, options);\r\n\r\n      // Rastrear último índice enviado para enviar solo incrementos\r\n      let ultimoIndiceEnviado = 0;\r\n\r\n      // Callback de progreso - enviar solo nuevos intentos\r\n      const progressCallback = (data) => {\r\n        const currentTime = performance.now();\r\n\r\n        // Obtener solo los intentos nuevos desde el último reporte\r\n        const nuevosIntentos = algo.attemptsHistory.slice(ultimoIndiceEnviado);\r\n        ultimoIndiceEnviado = algo.attemptsHistory.length;\r\n\r\n        self.postMessage({\r\n          type: 'colorProgress',\r\n          progress: data.progress,\r\n          attempts: data.attempts,\r\n          conflicts: data.conflicts,\r\n          colors: data.colors,\r\n          conflictEdges: data.conflictEdges,\r\n          meanConflicts: data.meanConflicts,\r\n          successRate: data.successRate,\r\n          timeMs: currentTime - startTime,\r\n          currentAttempt: data.currentAttempt,\r\n          newAttempts: nuevosIntentos  // Solo los nuevos intentos\r\n        });\r\n      };\r\n\r\n      const result = algo.run(progressCallback);\r\n      const endTime = performance.now();\r\n\r\n      self.postMessage({\r\n        type: 'colorComplete',\r\n        algorithm: 'Monte Carlo',\r\n        result: {\r\n          colors: result.colors,\r\n          conflictEdges: result.conflictEdges,\r\n          stats: {\r\n            ...result.stats,\r\n            timeMs: endTime - startTime\r\n          },\r\n          attemptsHistory: algo.attemptsHistory\r\n        }\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    self.postMessage({\r\n      type: 'error',\r\n      error: error.message,\r\n      stack: error.stack\r\n    });\r\n  }\r\n};\r\n"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","toPropertyKey","t","i","r","e","toPrimitive","call","TypeError","String","Number","_defineProperty","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","Node","id","x","y","this","Edge","sourceId","targetId","GRAPH_CONSTRAINTS","LAYOUT_ITERATIONS","FORCE_DIRECTED","ALGORITHM","COLOR_PALETTE","NAMES","ForceDirectedLayout","width","undefined","height","area","aplicar","nodos","aristas","iteraciones","numeroDeNodos","distanciaOptima","Math","sqrt","temperatura","tasaEnfriamiento","indiceIteracion","calcularFuerzasRepulsivas","calcularFuerzasAtractivas","aplicarFuerzas","nodo","forceX","forceY","_calcularDistanciaSegura","deltaX","deltaY","random","distancia","j","fuerzaRepulsiva","nodoMap","Map","map","n","arista","nodoOrigen","get","nodoDestino","fuerzaAtractiva","fuerzaX","fuerzaY","magnitudFuerza","desplazamiento","min","max","Graph","agregarNodo","Error","concat","siguienteIdNodo","nuevoNodo","agregarArista","some","nuevaArista","resetear","actualizarPosicionNodo","nodeId","find","eliminarArista","eliminarNodo","crearGrafoConectadoAleatorio","grafo","columnas","ceil","filas","generarCoordenada","col","fila","maxCol","maxFila","floor","nodoPrevio","extras","agregadas","intentos","maxIntentos","a","b","iteracionesLayout","aplicarLayoutFuerzas","coloracionAleatoria","coloresDisponibles","colores","color","calcularEstadisticasAlgoritmo","conteoExitos","totalConflictos","mejoresConflictos","attempts","conflicts","Infinity","meanConflicts","successRate","progress","BaseAlgorithm","graph","_options$numberOfColo","options","numeroColores","nodes","edges","numberOfColors","availableColors","slice","totalConflicts","successCount","bestColors","bestEvaluation","conflictEdges","finished","attemptsHistory","evaluarColoracion","mapaColores","conflictos","aristasConflicto","primerColor","segundoColor","obtenerMaximoIntentos","guardarIntentoEnHistorial","exito","attemptNumber","success","timestamp","Date","now","actualizarMejorSolucion","updateStatistics","run","progressCallback","lastStepResult","step","shouldReportProgress","done","calculateProgress","stats","colors","currentAttempt","LasVegas","_options$maxAttempts","super","maxAttempts","evalResult","attempt","MonteCarlo","_options$iterations","iterations","self","onmessage","type","data","startTime","performance","algo","ultimoIndiceEnviado","currentTime","nuevosIntentos","postMessage","timeMs","newAttempts","result","endTime","algorithm","_objectSpread","error","message","stack"],"ignoreList":[],"sourceRoot":""}